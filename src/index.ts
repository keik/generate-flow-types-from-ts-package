import { spawn } from "child_process";
import fs from "fs";
import path from "path";

import chalk from "chalk";
import { bundle } from "dts-bundle";
import enhancedResolve from "enhanced-resolve";
import { beautify, compiler } from "flowgen";
// import rimraf from "rimraf";

const pkg = require("../package.json"); // eslint-disable-line @typescript-eslint/no-var-requires

const TMP_DIR = "./tmp/generate-flowtype-from-ts";

const handleErrorToExit = (e: Error) => {
  console.error(chalk.red(e.stack));
  process.exit(1);
};

const createDeclsByTsc = async (
  packageName: string,
  entryFilepath: string,
  options: Options
): Promise<string> => {
  return new Promise((resolve, reject) => {
    const command = `npx tsc --lib es2015,dom --types --jsx react --esModuleInterop -d --emitDeclarationOnly --outDir ${TMP_DIR}/${packageName} ${entryFilepath}`;
    if (options.verbose) {
      console.info(
        chalk.cyan(
          `[tsc]: Create TypeScript declaration files with: ${command}`
        )
      );
    }

    const proc = spawn(command, [], { shell: true });
    const entryDelcFilepath = `${TMP_DIR}/${packageName}/${path
      .basename(entryFilepath)
      .replace(/\.tsx?$/, ".d.ts")}`;

    proc.stdout.on("data", (data) => {
      console.log(data.toString());
    });
    proc.on("error", (e) => {
      reject(e);
    });
    proc.on("exit", () => {
      resolve(entryDelcFilepath);
    });
  });
};

const bundleDecls = (
  packageName: string,
  entryDeclFilepath: string,
  options: Options
) => {
  const outFilepath = `${TMP_DIR}/${packageName}.d.ts`;
  if (options.verbose) {
    console.info(
      chalk.cyan(
        `[dts-bundle]: Bundle TypeScript declaration files of ${packageName} to ${outFilepath}`
      )
    );
  }
  bundle({
    name: packageName,
    main: entryDeclFilepath,
    out: `~/${outFilepath}`,
  });
  return outFilepath;
};

const createFlowTypes = (
  packageName: string,
  bundleDeclFilepath: string,
  options: Options
) => {
  const outFilepath = `${options.outdir}/${path
    .relative(TMP_DIR, bundleDeclFilepath)
    .replace(/\.d\.ts/, ".js")}`;
  if (options.verbose) {
    console.info(
      chalk.cyan(
        `[flowgen]: Generate Flow type from ${bundleDeclFilepath} to ${outFilepath}`
      )
    );
  }
  const flowdef =
    `\
/**
 * Flowtype definitions for ${packageName}
 * Generated by ${pkg.name}
 */

` + beautify(compiler.compileDefinitionFile(bundleDeclFilepath));
  if (options.verify) {
    if (
      !fs.existsSync(outFilepath) ||
      flowdef !== fs.readFileSync(outFilepath, "utf-8")
    ) {
      throw new Error(`verify: ðŸ™… ${outFilepath} is not synched.`);
    }
  } else {
    fs.writeFileSync(outFilepath, flowdef);
  }
  return outFilepath;
};

type Options = { outdir: string; verbose: boolean; verify: boolean };

const main = async (
  packagePaths: Array<string>,
  options: Options
): Promise<void> => {
  const resolve = enhancedResolve.create({ extensions: [".ts", ".tsx"] });

  await Promise.all(
    packagePaths.map((packagePath) =>
      (async () => {
        const hrstart = process.hrtime();
        const packageJson = fs
          .readFileSync(`${packagePath}/package.json`)
          .toString();
        const packageName = JSON.parse(packageJson).name;
        const entryFilepath = (await new Promise((res, rej) => {
          resolve(packagePath, "", (err: any, result: string) => {
            if (err) {
              rej(new Error(`Can't resolve entry of package: ${packagePath}`));
            }
            res(result);
          });
        })) as string;

        if (!RegExp(".tsx?").test(path.extname(entryFilepath)))
          throw Error(`Entry filepath must be .ts file: ${entryFilepath}`);
        if (!fs.existsSync(entryFilepath))
          throw Error(`Entry filepath is not exist: ${entryFilepath}`);

        const entryDelcFilepath = await createDeclsByTsc(
          packageName,
          entryFilepath,
          options
        );
        const bundleDeclFilepath = bundleDecls(
          packageName,
          entryDelcFilepath,
          options
        );
        const generatedFlowFilepath = createFlowTypes(
          packageName,
          bundleDeclFilepath,
          options
        );
        const hrend = process.hrtime(hrstart);
        if (options.verify) {
          console.info(
            chalk.green(`verify: ðŸ™† ${generatedFlowFilepath} is synced`)
          );
        } else {
          console.info(
            chalk.green(
              `generated: ${generatedFlowFilepath} (${(
                hrend[0] * 1000 +
                hrend[1] / 1000000
              ).toFixed(0)}ms)`
            )
          );
        }
      })().catch(handleErrorToExit)
    )
  ).catch(handleErrorToExit);
  // TODO: optional or use tempfile
  // rimraf.sync(TMP_DIR);
};

export default main;
